---
title: Objective-C对象模型及运行时_1
layout: post
tags: []
category: iOS
---
PreView:

本篇文章主要介绍OC的动态特性,很多内容都是来自于参考链接中的整理,相当于备份一下大神们的文章.没办法,本人太菜.有问题一起讨论.

1. 什么叫动态类型的语言?
2. OC是如何实现动态性的?
3. OC的对象模型是怎么样的?

## OC对象模型

Objective-C的runtime是开源的.
> [objc4](https://opensource.apple.com/tarballs/objc4/)

### id和Class

对象的类大体包含两种信息:对象占用的内存大小,成员变量的类型,布局等;对象能够响应的信息,实现的实例方法等.

#### objc_object
源码在objc-private.h中(runtime.h里面是旧实现了,这边看新的就可以了)
```
typedef struct objc_object *id;

struct objc_object {
private:
    isa_t isa;
public:
    // ISA() assumes this is NOT a tagged pointer object
    Class ISA();
    // getIsa() allows this to be a tagged pointer object
    Class getIsa();
    ...
}
```
Objective-C对象定义就是上面的结构体objc_object拥有唯一的私有变量就是isa.
注意id就是一个objc_object指针,这也是为什么id能指向任意对象的原因.

#### objc_class
源码在objc-runtime-new.h中
```
typedef struct objc_class *Class;

struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
    class_rw_t *data() { 
        return bits.data();
    }
    ... 省略其他方法
}
```
objc_class继承于objc_object.这也验证了我们经常听到的说法,Objective-C的类本身也是对象.注意Class就是一个指向objc_class的指针.


#### 元类
通过之前的例子,我们可以大致得到一个简单的结论
Objective-C对象有个isa指针指向类, 类也是一个对象.
那类对象的isa指针又指向谁呢?这就引出了一个新的概念,元类.

![oc对象模型](https://raw.githubusercontent.com/HighmoreXu/BlogImage/master/images/object_model.png "oc对象模型")

结合上图,我们可以得出更完整的结论.

* 对象的方法列表存于类中,对象的isa指向类; 类方法列表存于元类中,类的isa指向元类.元类的isa指向根元类, 所有的元类所属的类都是同一个根元类(当然根元类也是元类,所以他的isa指向自身, 具体来说根元类就是NSObject对应的元类)
* 方法调用遵循一个规则,即如果子类没有找到就去父类寻找.而类的方法列表是存于元类中的.因此类对象和元类对象应该保持相同的继承关系.

## Runtime

### 概览
对于[receiver message],以前大脑最好的理解方式就是简单的方法调用,但这个掩盖了其本质.

`ojc_msgSend(receiver, selector, arg1, arg2, ...)`

如果接收者能找到对应的selector,那么就相当于直接执行了这个对象的特定方法;否则,消息要么转发,或者临时向接收者动态添加这个selector对应的实现内容.或者崩溃掉.
所以其绝不是简单的方法调用.编译阶段只是确定了要向接收者发送message.但receiver如何响应这条消息,就要看运行时了.

### 基础结构

`id objc_msgSend ( id self, SEL op, ... );`

### SEL
selector在Objc中的表现类型,方法选择器.
`id objc_msgSend ( id self, SEL op, ... );`
可以简单理解为区分方法的ID,这个ID的数据机构是SEL.

### cache_t

```
struct cache_t {
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
    ... 省略其他方法
}
```
_buckets存储IMP. _mask和_occupied对应vtable
```
struct bucket_t {
private:
    cache_key_t _key;
    IMP _imp;

public:
    inline cache_key_t key() const { return _key; }
    inline IMP imp() const { return (IMP)_imp; }
    inline void setKey(cache_key_t newKey) { _key = newKey; }
    inline void setImp(IMP newImp) { _imp = newImp; }

    void set(cache_key_t newKey, IMP newImp);
};
```

之前我们已经了解到,对象的方法是存在类中的,如果每次都通过isa去查找的话势必有性能问题.
cache就是为了解决这个问题而存在的,响应消息时会优先在cache中查找.Runtime会把调用的方法存到cache中.

###




参考链接:

> [唐巧的技术博客](http://blog.devtang.com/2013/10/15/objective-c-object-model/)

> [雷纯锋的技术博客](http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/)

> [伽蓝之堂——
一只魔法师的工坊](https://blog.ibireme.com/2013/11/25/objc-object/)

> [玉令天下的博客](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)