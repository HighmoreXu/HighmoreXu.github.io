---
categories: Uncategoried
category: iOS
layout: post
tags: []
title: 'Objective-C runtime - category'
---
# 前言

通过前面的文章我们已经对OC的类结构有了大致的了解.
本篇文章主要基于OC的类来探究一下分类的实现机制.

## Category 结构
```
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
}; 
```

### method添加
category我们常用的用法就是为现有的类扩展方法,因此我们从method_list_t开始分析.

```
struct method_list_t : entsize_list_tt<method_t, method_list_t, 0x3> {
    // 成员变量和方法
};

template <typename Element, typename List, uint32_t FlagMask>
struct entsize_list_tt {
    uint32_t entsizeAndFlags;
    uint32_t count;
    Element first;
};
```
简单来说,method_list_t就是管理method_t的容器
```
struct method_t {
    SEL name;   // 方法名类型,相同名字的方法即使在不同的类中也相同
    const char *types;  // 方法类型,存储方法参数类型和返回值 
    IMP imp; // 方法的具体实现
};
```

存储所有category的结构体category_list
```
struct locstamped_category_list_t {
    uint32_t count;
    locstamped_category_t list[0];
};
struct locstamped_category_t {
    category_t *cat;
    struct header_info *hi;
};
typedef locstamped_category_list_t category_list;
```


#### 添加分类方法的流程
objc_init -> read_images -> remethodizeClass -> attachCategorys

我们目前关注的是如何添加分类方法,因此直接看attachCategorys的实现.
```
static void attachCategories(Class cls, category_list *cats, bool flush_caches) {
    if (!cats) return;
    bool isMeta = cls->isMetaClass();

    method_list_t **mlists = (method_list_t **)malloc(cats->count * sizeof(*mlists));
    // Count backwards through cats to get newest categories first
    int mcount = 0;
    int i = cats->count;
    while (i--) {
        auto& entry = cats->list[i];

        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist;
        }
    }

    auto rw = cls->data();

    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    rw->methods.attachLists(mlists, mcount);
    free(mlists);
    if (flush_caches  &&  mcount > 0) flushCaches(cls);
}
```
这里只保留了和方法相关的实现.整个流程也比较简单.
1. 创建一个存储method_list_t的指针数组. mlists指向该指针数组的起始地址.
2. 遍历category_list,即该类的所有扩展.每一个分类的方法列表都依次加到指针数组中.
3. class_rw_t进行attachLists的操作.

前两步都比较好理解,那第三步具体做了哪些事情呢?
之前我们已经了解了OC类大致结构.class_rw_t中包含了method_array_t的成员变量.
```
template <typename Element, typename List>{
    struct array_t {
        uint32_t count;
        List* lists[0];
    };
}
class method_array_t : public list_array_tt<method_t, method_list_t>
```
lists数组存储List类型的指针列表.
```
void attachLists(List* const * addedLists, uint32_t addedCount) {
    if (addedCount == 0) return;
    uint32_t oldCount = array()->count;
    uint32_t newCount = oldCount + addedCount;
    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
    array()->count = newCount;
    memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0]));
    memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0]));
}
```
realloc重新扩展空间.把原来的数组复制到后面,把新数组复制到前面.
因此,如果添加的分类方法和原有类重复,则相当于变相"替换"掉了原有的方法.且最后添加的分类方法最先生效.











